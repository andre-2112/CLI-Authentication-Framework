# Secret Mechanism in CCA Registration Flow

## Overview

The "secret" is a cryptographic security mechanism that provides an additional layer of authentication for the `/approve` endpoint. It prevents unauthorized approval of registration requests even if an attacker obtains the JWT token.

## How the Secret Mechanism Works

### 1. In `/register` Endpoint (Token Generation)

When a user submits a registration request, the Lambda function:

#### Step 1: Encrypts the Admin Email
```python
# Lines 136-147
encrypted_secret = kms.encrypt(
    KeyId=KMS_KEY_ID,
    Plaintext=ADMIN_EMAIL.encode('utf-8')
)
encrypted_secret_b64 = base64.urlsafe_b64encode(
    encrypted_secret['CiphertextBlob']
).decode('utf-8').rstrip('=')
```

#### Step 2: Stores Secret in TWO Places

**A. Inside the JWT Payload:**
```python
# Line 155
user_data = {
    'email': body['email'],
    'first_name': first_name,
    'last_name': last_name,
    'encrypted_password': encrypted_pwd_b64,
    'secret': encrypted_secret_b64,  # <-- Secret stored in JWT
    'submitted_at': datetime.utcnow().isoformat(),
    'expires_at': (datetime.utcnow() + timedelta(hours=48)).isoformat()
}
```

**B. In the Approve URL Query String:**
```python
# Lines 167-168
approve_url = f"{protocol}://{lambda_url}/approve?token={approve_token}&secret={encrypted_secret_b64}"
deny_url = f"{protocol}://{lambda_url}/deny?token={deny_token}"  # No secret!
```

**Key Point:** The `deny_url` does NOT include the secret parameter - only the approve URL requires it.

### 2. In `/approve` Endpoint (Token Verification)

When an admin clicks the approve link, the Lambda function performs triple verification:

#### Verification 1: Secret Exists in Query String
```python
# Lines 204, 209-211
secret_param = params.get('secret')

if not secret_param:
    print("[SECURITY] Approval attempt without secret parameter")
    return html_response('<h1>Error: Missing secret parameter</h1>', 403)
```

#### Verification 2: Secret Matches JWT Payload
```python
# Lines 220-223
secret_token = user_data.get('secret')  # From decoded JWT
if secret_param != secret_token:
    print(f"[SECURITY] Secret mismatch: URL secret does not match token secret")
    return html_response('<h1>Error: Invalid secret</h1>', 403)
```

This prevents mixing tokens and secrets from different registration requests.

#### Verification 3: Decrypted Secret Matches ADMIN_EMAIL
```python
# Lines 226-243
# Add padding back to URL-safe base64
secret_padded = secret_param + '=' * ((4 - len(secret_param) % 4) % 4)

# Decrypt using KMS
decrypted_secret = kms.decrypt(
    CiphertextBlob=base64.urlsafe_b64decode(secret_padded.encode())
)
decrypted_admin_email = decrypted_secret['Plaintext'].decode('utf-8')

# Verify it matches the expected admin email
if decrypted_admin_email != ADMIN_EMAIL:
    print(f"[SECURITY] Decrypted secret does not match ADMIN_EMAIL")
    return html_response('<h1>Error: Invalid secret</h1>', 403)
```

## Security Benefits

### 1. **Prevents Token Replay Attacks**
Even if an attacker captures the JWT token, they cannot approve registrations without the matching secret parameter from the query string.

### 2. **Prevents Token/Secret Mixing**
The secret inside the JWT must match the secret in the query string, preventing attackers from combining tokens and secrets from different requests.

### 3. **Cryptographic Verification**
The secret is the encrypted ADMIN_EMAIL. When decrypted via KMS, it must match the configured admin email. This ensures:
- Only someone with access to AWS KMS can decrypt it
- The secret was generated by this Lambda function
- The secret hasn't been tampered with

### 4. **Selective Protection**
Only the `/approve` endpoint requires the secret. The `/deny` endpoint does not, which makes sense because:
- Approvals create users and grant access (high security risk)
- Denials simply reject requests (lower security risk)

## Flow Diagram

```
[User Registers]
       ↓
[Lambda encrypts ADMIN_EMAIL with KMS] → encrypted_secret_b64
       ↓
       ├─→ [Stores in JWT payload] → user_data.secret
       └─→ [Adds to approve URL] → ?token=XXX&secret=YYY

[Admin Clicks Approve Link]
       ↓
[Lambda receives both token and secret]
       ↓
[Verification 1] → Secret parameter exists?
       ↓
[Verification 2] → secret_param == user_data.secret?
       ↓
[Verification 3] → KMS decrypt(secret) == ADMIN_EMAIL?
       ↓
[All verified] → Create Cognito user
```

## Example

### Registration Response:
```json
{
  "approve_url": "https://lambda-url.amazonaws.com/approve?token=eyJkYXRh...&secret=AQICAH...",
  "deny_url": "https://lambda-url.amazonaws.com/deny?token=eyJkYXRh..."
}
```

### Approve Request Requires:
```bash
curl "https://lambda-url/approve?token=TOKEN&secret=SECRET"
                                        ↑            ↑
                                       JWT      encrypted admin email
```

### Deny Request Only Requires:
```bash
curl "https://lambda-url/deny?token=TOKEN"
                                   ↑
                                  JWT only
```

## Why This Design?

1. **Defense in Depth**: Multiple layers of verification
2. **KMS Integration**: Leverages AWS KMS for cryptographic operations
3. **Tamper Detection**: Any modification to token or secret will fail verification
4. **Audit Trail**: All verification failures are logged
5. **Separation of Concerns**: Approval and denial have appropriate security levels

## Implementation Files

- **Lambda Function**: `lambda/lambda_function.py`
  - `/register` handler: Lines 90-196
  - `/approve` handler: Lines 198-568
  - Secret encryption: Lines 136-147
  - Secret verification: Lines 219-243
